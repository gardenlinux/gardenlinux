#!/usr/bin/env python3

# Temporary solution to figure out "latest" gardenlinux release.
# Permanent solution is developed here:
# https://github.com/gardenlinux/gardenlinux/issues/2389

import subprocess
import json
import sys
import argparse
import re

def get_versions():
    """Use gh CLI api endpoint to query container image versions."""
    try:
        command = [
            "gh", "api", "--paginate",
            "-H", "Accept: application/vnd.github+json",
            "-H", "X-GitHub-Api-Version: 2022-11-28",
            "/orgs/gardenlinux/packages/container/gardenlinux/versions"
        ]
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0:
            print(f"Error running gh command: {result.stderr}", file=sys.stderr)
            sys.exit(1)
        return json.loads(result.stdout)
    except Exception as e:
        print(f"Error executing gh command: {str(e)}", file=sys.stderr)
        sys.exit(1)

def find_tag(data, tag_name):
    """Find a specific tag and return its metadata."""
    for version in data:
        if tag_name in version['metadata']['container']['tags']:
            return version
    return None

def find_most_recent_version_with_prefix(data, prefix):
    """Find the most recent version that matches the given prefix (e.g., '1571' -> '1571.1')."""
    matching_versions = []
    version_regex = re.compile(rf'^{re.escape(prefix)}\.\d+$')  # Match prefix with '.x'

    for version in data:
        for tag in version['metadata']['container']['tags']:
            if version_regex.match(tag):
                matching_versions.append(tag)
    
    if not matching_versions:
        return None

    # Sort the matching versions by the numeric suffix (e.g., 1571.1 > 1571.0)
    matching_versions.sort(key=lambda v: float(v.split('.')[1]), reverse=True)
    return matching_versions[0]  # Return the most recent version

def extract_version_from_metadata(metadata):
    """Extract the first valid version tag using regex."""
    tags = metadata['metadata']['container']['tags']
    # Use regex to select a tag that looks like a version number (e.g., 1646.0, 16461.0)
    version_regex = re.compile(r'^\d+\.\d+$')
    for tag in tags:
        if version_regex.match(tag):
            return tag
    return None

def get_git_commit_from_tag(tag, short=False):
    """Fetch the git commit for a given tag from the repository using gh api."""
    try:
        # Use gh API to fetch the commit associated with a tag
        command = ["gh", "api", f"/repos/gardenlinux/gardenlinux/git/refs/tags/{tag}", "--jq", ".object.sha"]
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0:
            print(f"Error fetching git commit from tag: {tag}, {result.stderr}", file=sys.stderr)
            sys.exit(1)

        # Get the full commit hash
        commit_ref = result.stdout.strip()

        if short:
            return commit_ref[:8]
        return commit_ref
    except Exception as e:
        print(f"Error fetching git commit from tag: {e}", file=sys.stderr)
        sys.exit(1)

def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Fetch Garden Linux image version and corresponding Git commit using the GitHub CLI.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--latest", action="store_true", help="Use the latest released Garden Linux")
    # group.add_argument("--nightly", action="store_true", help="Use the Garden Linux nightly build")
    group.add_argument("--release", type=str, help="Specify a Garden Linux release (e.g., 1592.1 or 1433)")
    # group.add_argument("--dev", type=str, help="Specify a Garden Linux development release by passing a $release-$commit combination (e.g. 1639.0-928117ea)")
    parser.add_argument("--commit", action="store_true", help="Fetch the full Git commit associated with the tag")
    parser.add_argument("--commit-short", action="store_true", help="Fetch the short Git commit (first 8 characters) associated with the tag")
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_arguments()

    # Fetch all versions
    data = get_versions()

    # Handle different tag selections
    selected_metadata = None
    tag = None
    commit = None

    if args.latest:
        selected_metadata = find_tag(data, 'latest')
        if not selected_metadata:
            print("Error: No 'latest' tag found.", file=sys.stderr)
            sys.exit(1)
        tag = extract_version_from_metadata(selected_metadata)
    # elif args.nightly:
    #     selected_metadata = find_tag(data, 'nightly')
    #     if not selected_metadata:
    #         print("Error: No 'nighlty' tag found.", file=sys.stderr)
    #         sys.exit(1)
    #     tag = extract_version_from_metadata(selected_metadata)
    # elif args.dev:
    #     try:
    #         tag, commit = args.dev.split('-')
    #         # print(f"{tag}-{commit}")
    #         # sys.exit(0)
    #     except ValueError:
    #         print("Error: Input should be in the format $tag-$commit or $tag-$commit-short.", file=sys.stderr)
    #         sys.exit(1)
    elif args.release:
        # Check if the provided release tag has a decimal (e.g., '1571.0')
        if '.' not in args.release:
            # If no decimal is present, find the most recent version with the same prefix
            most_recent_version = find_most_recent_version_with_prefix(data, args.release)
            if most_recent_version:
                tag = most_recent_version
            else:
                print(f"Error: No versions found with prefix '{args.release}'", file=sys.stderr)
                sys.exit(1)
        else:
            # If the tag is complete (e.g., '1641.0'), find it directly
            selected_metadata = find_tag(data, args.release)
            if not selected_metadata:
                print(f"Error: Tag '{args.release}' not found.", file=sys.stderr)
                sys.exit(1)
            tag = args.release

    # Output the combined tag and Git commit if --commit or --commit-short is provided
    if args.commit or args.commit_short:
        if not tag:
            print("Error: No tag found to fetch Git commit.", file.sys.stderr)
            sys.exit(1)
        
        if not commit:
            # Fetch the Git commit from the tag directly using gh api
            commit = get_git_commit_from_tag(tag, short=args.commit_short)
        print(f"{tag}-{commit}")
    else:
        # Output the resolved version tag
        if tag:
            print(tag)
        else:
            print("Error: No version tag found.", file.sys.stderr)

