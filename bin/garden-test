#!/usr/bin/env bash
set -Eeuo pipefail

thisDir="$(dirname "$(readlink -f "$BASH_SOURCE")")"
source "$thisDir/.constants.sh" \
	--flags 'no-build,debug,skip-tests,suite:,gardenversion:,timestamp:' \
	--flags 'ports,arch:,qemu,features:,disable-features:,disable-images:,commitid:,userid:,usergid:' \
	--flags 'suffix:,prefix:' \
	--

export PATH="${thisDir}:${PATH}"
export REPO_ROOT="$(readlink -f "${thisDir}/..")"

commitid="${commitid:-local}"
eval "$dgetopt"
while true; do
	flag="$1"; shift
	dgetopt-case "$flag"
	case "$flag" in
		--debug) debug=1 ;;	# for jumping in the prepared image"
		--ports) ports=1 ;;	# for using "debian-ports"
		--arch) arch="$1"; shift ;; # for adding "--arch" to garden-init
		--qemu) qemu=1 ;;	# for using "qemu-debootstrap"
		--features) features="$1"; shift ;; # adding features
		--disable-features) disablefeatures="$1"; shift ;; # ignoring features
		--disable-images) disableimages="$1"; shift ;;
		--suite) suite="$1"; shift ;; # suite is a parameter this time
		--gardenversion|--timestamp) version="$1"; shift ;; # timestamp is a parameter this time
		--suffix) suffix="$1"; shift ;; # target name prefix
		--prefix) prefix="$1"; shift ;; # target name suffix
		--commitid) commitid="$1"; shift ;; # build commit hash
		--skip-tests) tests=0 shift ;; # skip tests
		--userid) userID="$1" shift ;;
		--usergid) userGID="$1" shift ;;
		--) break ;;
		*) eusage "unknown flag '$flag'" ;;
	esac
done

if [ ${debug:-} ]; then
	set -x
fi

userID="${userID:-$(id -u)}";
userGID="${userGID:-$(id -g)}";
disablefeatures="${disablefeatures:-}"
disableimages="${disableimages:-}"
epoch="$(garden-version --epoch "$version")"
serial="$(garden-version --date "$version")"
dpkgArch="${arch:-$(dpkg --print-architecture | awk -F- "{ print \$NF }")}"
targetBase=""
export arch="$arch"
rootfs="/rootfs"

fullfeatures="$(garden-feat --featureDir $featureDir --features "$features" --ignore "$disablefeatures" features)"

if [ -z "${prefix+x}" ]; then
	prefix="/$(garden-feat --featureDir $featureDir --features "$features" --ignore "$disablefeatures" cname)-$dpkgArch-$version-$commitid"
fi

exportDir="output"
outputDir="$exportDir$prefix"

if [ "${OUTPUT_DIR+defined}" ]; then
	outputDir="${OUTPUT_DIR}${prefix}"
	testsLog="${outputDir}/test.log"
	mkdir -p "${outputDir}"
	touch "${testsLog}"
else
	volumeDir="/output$prefix"
	testsLog="/output${prefix}_tests.log"

	touch "${testsLog}"
	chown "${userID}":"${userGID}" "${testsLog}"
	chmod 644 "${testsLog}"
fi

echo > "${testsLog}"
exec > >(tee -a "${testsLog}") 2> >(tee -a "${testsLog}" >&2)

touch_epoch() {
	while [ "$#" -gt 0 ]; do
		local f="$1"; shift
		touch --no-dereference --date="@$epoch" "$f"
	done
}

# sshwatch function
# QEMU directly opens the local port. Therefore, a regular
# tcp check will triggert to be fine. However, we want to
# know when the real sshd within the VM is up and running.
sshwatch() {
    echo "Waiting for SSH on port $1 to become ready..."
    while ! ssh-keyscan -p $1 localhost ; do sleep 2 ; done
    echo "SSH on port $1 is ready."

}

# Extract and use pre built
# rootfs from production
mkdir -p /rootfs/
tar xf /output/${prefix}.tar.xz -C /rootfs/
echo $epoch > /rootfs/garden-epoch

# Start unit tests
echo "#### tests"
disabledBy=""
enabledBy=""
testcounter=0
failcounter=0
skipcounter=0

mkdir -p rootfs/etc/ssl
mount --bind /etc/ssl rootfs/etc/ssl
garden-apt-get $rootfs update

# Define APT settings and install
# needed dependencies
sed -i 's/testing/bookworm/g' /etc/apt/sources.list
rm /etc/apt/apt.conf.d/default-testing
apt-get update
apt-get -y install procps iproute2 rsync openssh-client qemu-system-arm qemu-system-x86

# Find unit tests in activated features
for t in $(find $featureDir/*/test/ -maxdepth 1 -type f -executable -exec basename {} \; | grep -v .disable | sort | uniq); do
        let "testcounter=testcounter+1"
        test=$(basename $t | cut -d. -f 1)
        if [ "${tests:-1}" = "0" ]; then
                echo "test ${test} is being skipped, --skip-tests has been used"
                let "skipcounter=skipcounter+1"
                continue
        fi
        # go over features and build the enabled/disabled lists
        # a test with .disabled in a specific feature disables the test globally
        # a test that is not executable is not enabled for the specific feature
        for f in $(tr ',' '\n' <<< $fullfeatures); do
                featureTest="${featureDir}/${f}/test/${test}"
                if [ -f "${featureTest}.disable" ]; then
                        disabledBy=$(echo "${f} ${disabledBy}")
                        continue
                fi
                if [ -f "${featureTest}.chroot" ]; then
                        if [ ! -x "${featureTest}.chroot" ]; then
                                continue
                        fi
                        enabledBy=$(echo "${f} ${enabledBy}")
                        continue
                fi
                if [ -f "${featureTest}.startvm" ]; then
                        if [ ! -x "${featureTest}.startvm" ]; then
                                continue
                        fi
                        enabledBy=$(echo "${f} ${enabledBy}")
                        continue
                fi
                if [ -f "${featureTest}" ]; then
                        if [ ! -x "${featureTest}" ]; then
                                continue
                        fi
                        enabledBy=$(echo "${f} ${enabledBy}")
                fi
        done
        if [ "$disabledBy" != "" ]; then
                echo "test ${test} is disabled by the following features: ${disabledBy}"
                # remove disabled tests that might be enabled in another feature
                enabledBy=$(echo $enabledBy |  tr " " "\n" | grep -vf <(echo $disabledBy | tr " " "\n"))
        elif [ "$enabledBy" != "" ]; then
                echo "test ${test} is enabled by the following features: ${enabledBy}"
                # prepare all other dependencies from the test
                for fd in $(echo "${enabledBy}"); do
                        if [ -d "${featureDir}/${fd}/test/${test}.d" ]; then
                                mkdir -p "${rootfs}/tmp/${test}.d"
                                for fdep in "${featureDir}/${fd}/test/${test}.d"/*; do
                                        [ -e "$fdep" ] || continue
                                        fdepshort=$(basename $fdep)
                                        if [[ "$fdepshort" == "pkg.include" || "$fdepshort" == "pkg.exclude" ]]; then
                                                cat $fdep | filter_variables | filter_if >> "${rootfs}/tmp/${test}.d/${fdepshort}.list"
                                        else
                                                cat $fdep >> "${rootfs}/tmp/${test}.d/${fdepshort}"
                                        fi
                                done
                        fi
                done

                # move the actual tests from one of the features that enables it
                actualTest="${featureDir}/$(echo ${enabledBy} | awk '{ print $1 }')/test/${t}"

		# Test: chroot 
                if [ ${t##*.} == "chroot" ]; then
                        cp -L ${actualTest} "${rootfs}/tmp/${test}"
                        if garden-chroot "${rootfs}" ./tmp/${test}; then
                                echo -e "\e[32mpassed\e[39m"
                                echo
                        else
                                echo -e "\e[31mfailed\e[39m"
                                echo
                                let "failcounter=failcounter+1"
                        fi

		# Test: startvm (running in qemu)
                elif [ ${t##*.} == "startvm" ]; then
                        cp -L ${actualTest} "${rootfs}/tmp/${test}"
			# Strip trailing whitespace
			startvmUser=$(echo ${enabledBy} | head -c-1)
			# Create a temporary and only for unit tests valid
			# ssh key for each user and feature
			garden-chroot "${rootfs}" useradd -m ${startvmUser}
			garden-chroot "${rootfs}" adduser ${startvmUser} wheel
			garden-chroot "${rootfs}" mkdir -p /home/${startvmUser}/tests/
			garden-chroot "${rootfs}" mkdir -p /home/${startvmUser}/.ssh/
			garden-chroot "${rootfs}" chmod 700 /home/${startvmUser}/.ssh/
			/rootfs/usr/bin/ssh-keygen -q -t rsa -N '' -f /rootfs/home/${startvmUser}/.ssh/id_rsa -m pem
			cp /rootfs/home/${startvmUser}/.ssh/id_rsa.pub /rootfs/home/${startvmUser}/.ssh/authorized_keys
			garden-chroot "${rootfs}" chmod 600 /home/${startvmUser}/.ssh/authorized_keys
			garden-chroot "${rootfs}" chown -R ${startvmUser}:${startvmUser} /home/${startvmUser}/.ssh/
			# Copy whole test directory to features home directory
			rsync -aP "${featureDir}/${startvmUser}/test/" /rootfs/home/${startvmUser}/tests/
			# Build new disk from modified root fs for unit tests
			# (This image will be dropped afterwards)
	                for i in $(tr ',' '\n' <<< $fullfeatures); do
                        	if [[ ",$disableimages," = *",$i,"* ]]; then # skip if image is in disableimages list
                            	   	true
                        	elif [ -s $featureDir/$i/image ]; then
                                	"$featureDir/$i/image" "$rootfs" "$targetBase"
                        	elif [ -f "$featureDir/$i/fstab" ]; then
                                	makepart "$rootfs" "$arch" < "$featureDir/$i/fstab" | makedisk "$rootfs" "test.raw"
                        	else
                                	true
                        	fi
                	done
			# Start new generated image for unit tests
			qemu-system-x86_64 -display none -daemonize -pidfile /tmp/qemu.pid -m 1024M -device virtio-net-pci,netdev=net0,mac=02:9f:ec:22:f8:89 -netdev user,id=net0,hostfwd=tcp::2223-:22,hostname=garden /tmp/test.raw

			# Wait for SSH in VM to be present
			# Default: tcp/2223
			echo "Starting VM - this will take some time"
			sshwatch 2223
			# Finally perform test
			ssh -i /rootfs/home/${startvmUser}/.ssh/id_rsa ${startvmUser}@localhost -p 2223 -o StrictHostKeyChecking=no /home/${startvmUser}/tests/${test}.startvm
                        if [ $? -ne 0 ]; then
                                echo -e "\e[31mfailed\e[39m"
                                echo
                                let "failcounter=failcounter+1"
                        else
                                echo -e "\e[32mpassed\e[39m"
                                echo
                        fi
			# Stop QEMU
			pkill -F /tmp/qemu.pid

		# Test: Others	
                else
                        if "${actualTest}" ${rootfs}; then
                                echo -e "\e[32mpassed\e[39m"
                                echo
                        else
                                echo -e "\e[31mfailed\e[39m"
                                echo
                                let "failcounter=failcounter+1"
                        fi
                fi
                rm -rf "${rootfs}/tmp/${test}.d"
                rm -f "${rootfs}/tmp/$test"
        elif [ "$enabledBy" == "" ]; then
                echo "test ${test} is not enabled in any feature, skipping"
                let "skipcounter=skipcounter+1"
                echo
        fi
        disabledBy=""
        enabledBy=""
done

umount rootfs/etc/ssl
echo "Tests done. ${failcounter}/${testcounter} failed. ${skipcounter}/${testcounter} skipped."
