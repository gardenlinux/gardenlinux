#!/usr/bin/env bash

set -Eeuo pipefail

# redirect all output to stderr so only second pass output for makedisk gets written to stdout
exec 3>&1
exec 1>&2

rootfs="$1"

rootfs_work=$(mktemp -d)
mnt=$(mktemp -d)

cp -a "$rootfs/." "$rootfs_work"

chcon -R system_u:object_r:unlabeled_t:s0 "$rootfs_work"
chroot "$rootfs_work" /sbin/setfiles /etc/selinux/default/contexts/files/file_contexts /
rm "$rootfs_work/.autorelabel"

# setup systemd boot (setting SYSTEMD_ESP_PATH env needed to bypass bootctl checking if mounted from esp partition)
touch "$rootfs_work/boot/efi/loader/loader.conf"
chroot "$rootfs_work" /usr/bin/env -i SYSTEMD_ESP_PATH="/boot/efi" bootctl --no-variables install

fstab=$(mktemp)

# strip comments and blank lines and sort by path depth (deepest first)
sed 's/#.*//;/^[[:blank:]]*$/d' \
| while IFS= read -r line; do
	# get fstab entry target path depth
	depth=$(echo "$line" | awk '{ print $2 }' | sed 's#^/\+##;s#/\+$##' | awk -F '/' '{ print NF }')
	echo "$depth" "$line"
  done \
| sort -k 1 -n -r \
| while read -r depth source target fs options args; do
	# set dump and pass options for output fstab to defaults
	dump=0
	pass=$( ([[ "$(cut -c 1 <<< "$target")" != "/" ]] && echo 0) || ([[ "$target" = "/" ]] && echo 1) || echo 2)
	if [[ "$depth" = 0 ]]; then
		options="$options,x-systemd.growfs"
	fi
	echo "$source" "$target" "$fs" "$options" "$dump" "$pass" >> "$fstab"

	# parse extra fstab arguments to determine partition attributes
	type=$([[ "$fs" = "swap" ]] && echo "swap" || echo "linux")
	size=
	resize=1
	syslinux=$([[ "$(cut -c -5 <<< "$target")" = "/boot" ]] && [[ -f "$rootfs/usr/bin/syslinux" ]] && echo 1 || echo 0)
	while IFS="=" read -r key value; do
		case "$key" in
			"type")
				type="$value"
				;;
			"size")
				size="$value"
				resize=0
				;;
			"syslinux")
				syslinux=1
				;;
		esac
	done < <(echo "$args" | tr "," "\n")

	# check if fstab entry specifies source by UUID or LABEL
	uuid=$(grep -oP '(?<=^UUID=)[a-fA-F0-9\-]*$' <<< "$source" || true)
	label=$(grep -oP '(?<=^LABEL=)[a-zA-Z0-9\_\-]*$' <<< "$source" || true)

	# compute sufficiently padded size for partition (aligned to nearest MB (2048 sectors))
	size=${size:-$(du -sb "$rootfs_work$target" | awk '{ size = $1 * 1.25; padded_size = size + (MB - (size % MB) % MB); print (padded_size / MB) "MiB" }' 'MB=1048576')}

	file=$(mktemp)
	truncate -s "$size" "$file"

	case "$fs" in
		"ext4")
			mkfs.ext4 ${uuid:+"-U"} ${uuid:+"$uuid"} ${label:+"-L"} ${label:+"$label"} -I 256 "$file"
			;;
		"vfat")
			mkfs.vfat ${uuid:+"-i"} ${uuid:+"$uuid"} ${label:+"-n"} ${label:+"$label"} "$file"
			;;
		"swap")
			mkswap ${uuid:+"-U"} ${uuid:+"$uuid"} ${label:+"-L"} ${label:+"$label"} "$file"
			;;
		*)
			echo "filesystem type $fs not yet supported"
			exit 1
			;;
	esac

	# for mount points (i.e. not swap, etc) copy from rootfs
	if [[ "$(cut -c 1 <<< "$target")" = "/" ]]; then
		mount -t "$fs" -o loop "$file" "$mnt"
		cp -a "$rootfs_work$target/." "$mnt"
		if [[ "$depth" = 0 ]]; then
			# we iterate depth sorted, so all other partitions should already have been processed and written to fstab
			column -t "$fstab" > "$mnt/etc/fstab"
		fi
		umount "$mnt"
		rm -rf "$rootfs_work$target"
		mkdir "$rootfs_work$target"
	fi

	# for ext4 set quota options and resize to minimum needed for contents (when run on a file resize2fs automatically truncates)
	if [[ "$fs" = "ext4" ]]; then
		tune2fs -Q usrquota,grpquota,prjquota "$file"
		if [[ "$resize" = 1 ]]; then
			e2fsck -y -f "$file" || [[ $? == 1 ]] # exit code 1: "File system errors corrected"
			resize2fs -M "$file"

			if [[ "$depth" = 0 ]]; then
				# add small size overhead/buffer to root partition for selinux first boot magic
				# (otherwise we'll get "A valid context for root could not be obtained." error at login)
				size=$(du -b "$file" | awk '{ padded_size = $1 + (MB - ($1 % MB) % MB); print (padded_size / MB) + 16 "MiB" }' 'MB=1048576')
				truncate -s "$size" "$file"
				resize2fs "$file"
			fi
		fi
	fi

	# install syslinux if extra argument given in fstab
	if [[ "$syslinux" = 1 ]]; then
		PATH="$PATH:$rootfs/usr/bin" syslinux -d syslinux -i "$file"
	fi

	# recalc size, since it might have change (e.g. from resize2fs)
	size=$(du -b "$file" | awk '{ padded_size = $1 + (MB - ($1 % MB) % MB); print (padded_size / MB) }' 'MB=1048576')

	# known uuids (rather than auto generated by fdisk) needed to query offsets later on
	part_uuid=$(cat /proc/sys/kernel/random/uuid)

	echo -e "$part_uuid\t$type\t$size\t$syslinux\t$file\t$label" >&3
  done

# cleanup
rm -rf "$rootfs_work" "$mnt" "$fstab"
