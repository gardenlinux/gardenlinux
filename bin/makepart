#!/usr/bin/env bash

set -Eeuo pipefail

# redirect all output to stderr so only second pass output for makedisk gets written to stdout
exec 3>&1
exec 1>&2

function uuid_hash {
	hash=$(sha256sum)
	echo "${hash:0:8}-${hash:8:4}-${hash:12:4}-${hash:16:4}-${hash:20:12}"
}

rootfs="$1"

rootfs_work=$(mktemp -d)

cp -a "$rootfs/." "$rootfs_work"

rm -rf "$rootfs_work/var/log"

chcon -R system_u:object_r:unlabeled_t:s0 "$rootfs_work"
chroot "$rootfs_work" /sbin/setfiles /etc/selinux/default/contexts/files/file_contexts /
rm "$rootfs_work/.autorelabel"

# setup systemd boot (setting SYSTEMD_ESP_PATH env needed to bypass bootctl checking if mounted from esp partition)
touch "$rootfs_work/boot/efi/loader/loader.conf"
chroot "$rootfs_work" /usr/bin/env -i SYSTEMD_ESP_PATH="/boot/efi" bootctl --no-variables --make-machine-id-directory=no install
rm "$rootfs_work/boot/efi/loader/random-seed" # random seed would obviously break reproducibility

fstab=$(mktemp)

timestamp=$(garden-version --epoch "$version")
export E2FSPROGS_FAKE_TIME=$timestamp

# strip comments and blank lines and sort by path depth (deepest first)
sed 's/#.*//;/^[[:blank:]]*$/d' \
| while IFS= read -r line; do
	# get fstab entry target path depth
	depth=$(echo "$line" | awk '{ print $2 }' | sed 's#^/\+##;s#/\+$##' | awk -F '/' '{ print NF }')
	echo "$depth" "$line"
  done \
| sort -k 1 -n -r \
| while read -r depth source target fs options args; do
	# set dump and pass options for output fstab to defaults
	dump=0
	pass=$( ([[ "$(cut -c 1 <<< "$target")" != "/" ]] && echo 0) || ([[ "$target" = "/" ]] && echo 1) || echo 2)
	if [[ "$depth" = 0 ]]; then
		options="$options,x-systemd.growfs"
	fi
	echo "$source" "$target" "$fs" "$options" "$dump" "$pass" >> "$fstab"

	# parse extra fstab arguments to determine partition attributes
	type=$([[ "$fs" = "swap" ]] && echo "swap" || echo "linux")
	size=
	resize=1
	syslinux=$([[ "$(cut -c -5 <<< "$target")" = "/boot" ]] && [[ -f "$rootfs/usr/bin/syslinux" ]] && echo 1 || echo 0)
	while IFS="=" read -r key value; do
		case "$key" in
			"type")
				type="$value"
				;;
			"size")
				size="$value"
				resize=0
				;;
			"syslinux")
				syslinux=1
				;;
		esac
	done < <(echo "$args" | tr "," "\n")

	# check if fstab entry specifies source by UUID or LABEL
	uuid=$(grep -oP '(?<=^UUID=)[a-fA-F0-9\-]*$' <<< "$source" || true)
	label=$(grep -oP '(?<=^LABEL=)[a-zA-Z0-9\_\-]*$' <<< "$source" || true)

	# compute sufficiently padded size for partition (aligned to nearest MB (2048 sectors))
	size=${size:-$(du -sb "$rootfs_work$target" | awk '{ size = $1 * 1.25; padded_size = size + (MB - (size % MB) % MB); print (padded_size / MB) "MiB" }' 'MB=1048576')}

	file=$(mktemp)
	truncate -s "$size" "$file"

	if [[ "$depth" = 0 ]]; then
		# we iterate depth sorted, so all other partitions should already have been processed and written to fstab
		column -t "$fstab" > "$rootfs_work/etc/fstab"
	fi

	case "$fs" in
		"ext4")
			# set uuid and HTREE hash_seed to reproducible values instead of default random generated ones
			uuid=${uuid:-$(echo "gardenlinux:$version:fs_uuid:$fs:$target" | uuid_hash)}
			hash_seed=$(echo "gardenlinux:$version:ext4_hash_seed:$fs:$target" | uuid_hash)
			mke2fs -E hash_seed="$hash_seed" -U "$uuid" ${label:+"-L"} ${label:+"$label"} -I 256 -d "$rootfs_work$target" "$file"

			# set quota options and resize to minimum size needed for contents (when run on a file resize2fs automatically truncates)
			tune2fs -Q usrquota,grpquota,prjquota "$file"
			resize2fs -M "$file"

			if [[ "$depth" = 0 ]]; then
				# add small size overhead/buffer to root partition
				size=$(du -b "$file" | awk '{ padded_size = $1 + (MB - ($1 % MB) % MB); print (padded_size / MB) + 16 "MiB" }' 'MB=1048576')
				truncate -s "$size" "$file"
				resize2fs "$file"
			fi

			# fixup timestamp on all used inodes to create reproducible ext4 image
			num_inodes=$(dumpe2fs -h "$file" 2> /dev/null | grep '^Inode count:' | cut -d ':' -f 2 | tr -d ' ')
			used_inodes=$(for (( inode=1; inode <= "$num_inodes"; inode++ )); do echo "testi <$inode>"; done | debugfs "$file" 2> /dev/null | grep -oP '(?<=Inode )[0-9]+(?= is marked in use)')
			for inode in $used_inodes; do for field in {a,m,c}time; do echo "set_inode_field <$inode> $field $timestamp"; done; done | debugfs -w "$file" &> /dev/null

			rm -rf "$rootfs_work$target"
			mkdir "$rootfs_work$target"
			;;
		"vfat")
			uuid=${uuid:-$(echo "gardenlinux:$version:fs_uuid:$fs:$target" | sha256sum | cut -c -8)}
			faketime "@$timestamp" mformat -i "$file" -F -N "$uuid" ${label:+"-v"} ${label:+"$label"} ::
			pushd "$rootfs_work$target"
				faketime "@$timestamp" mcopy -i "$file" -s -p $(ls -A) ::
			popd
			rm -rf "$rootfs_work$target"
			mkdir "$rootfs_work$target"
			;;
		"swap")
			uuid=${uuid:-$(echo "gardenlinux:$version:fs_uuid:$fs:$target" | uuid_hash)}
			mkswap -U "$uuid" ${label:+"-L"} ${label:+"$label"} "$file"
			;;
		*)
			echo "filesystem type $fs not yet supported"
			exit 1
			;;
	esac

	# # install syslinux if extra argument given in fstab
	# if [[ "$syslinux" = 1 ]]; then
	# 	PATH="$PATH:$rootfs/usr/bin" syslinux -d syslinux -i "$file"
	# fi

	# recalc size, since it might have change (e.g. from resize2fs)
	size=$(du -b "$file" | awk '{ padded_size = $1 + (MB - ($1 % MB) % MB); print (padded_size / MB) }' 'MB=1048576')

	part_uuid=$(echo "gardenlinux:$version:part_uuid:$source" | uuid_hash)

	echo "$target $(sha256sum "$file")"

	echo -e "$part_uuid\t$type\t$size\t$syslinux\t$file\t$label" >&3
  done

# cleanup
rm -rf "$rootfs_work" "$fstab"
