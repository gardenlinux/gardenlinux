From: Ben Hutchings <ben@decadent.org.uk>
Date: Tue, 26 Jun 2018 16:59:01 +0100
Subject: Export symbols needed by Android drivers
Bug-Debian: https://bugs.debian.org/901492

We want to enable use of the Android ashmem and binder drivers to
support Anbox, but they should not be built-in as that would waste
resources and increase security attack surface on systems that don't
need them.

Export the currently un-exported symbols they depend on.

---
 fs/file.c           | 5 +++++
 kernel/fork.c       | 1 +
 kernel/sched/core.c | 1 +
 kernel/signal.c     | 1 +
 kernel/task_work.c  | 1 +
 mm/memory.c         | 1 +
 mm/shmem.c          | 1 +
 mm/vmalloc.c        | 2 ++
 security/security.c | 4 ++++
 9 files changed, 17 insertions(+)

--- a/fs/file.c
+++ b/fs/file.c
@@ -409,6 +409,7 @@ struct files_struct *get_files_struct(st

        return files;
 }
+EXPORT_SYMBOL_GPL(get_files_struct);

 void put_files_struct(struct files_struct *files)
 {
@@ -421,6 +422,7 @@ void put_files_struct(struct files_struc
                kmem_cache_free(files_cachep, files);
        }
 }
+EXPORT_SYMBOL_GPL(put_files_struct);

 void reset_files_struct(struct files_struct *files)
 {
@@ -533,6 +535,7 @@ out:
        spin_unlock(&files->file_lock);
        return error;
 }
+EXPORT_SYMBOL_GPL(__alloc_fd);

 static int alloc_fd(unsigned start, unsigned flags)
 {
@@ -606,6 +609,7 @@ void __fd_install(struct files_struct *f
        rcu_assign_pointer(fdt->fd[fd], file);
        rcu_read_unlock_sched();
 }
+EXPORT_SYMBOL_GPL(__fd_install);

 void fd_install(unsigned int fd, struct file *file)
 {
@@ -668,6 +672,7 @@ out_unlock:
        *res = NULL;
        return -ENOENT;
 }
+EXPORT_SYMBOL(__close_fd_get_file);

 void do_close_on_exec(struct files_struct *files)
 {
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1085,6 +1085,7 @@ void mmput_async(struct mm_struct *mm)
                schedule_work(&mm->async_put_work);
        }
 }
+EXPORT_SYMBOL_GPL(mmput_async);
 #endif

 /**
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -3943,6 +3943,7 @@ int can_nice(const struct task_struct *p
        return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
                capable(CAP_SYS_NICE));
 }
+EXPORT_SYMBOL_GPL(can_nice);

 #ifdef __ARCH_WANT_SYS_NICE

--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1353,6 +1353,7 @@ struct sighand_struct *__lock_task_sigha

        return sighand;
 }
+EXPORT_SYMBOL_GPL(__lock_task_sighand);

 /*
  * send signal info to all the members of a group
--- a/kernel/task_work.c
+++ b/kernel/task_work.c
@@ -40,6 +40,7 @@ task_work_add(struct task_struct *task,
                set_notify_resume(task);
        return 0;
 }
+EXPORT_SYMBOL(task_work_add);

 /**
  * task_work_cancel - cancel a pending work added by task_work_add()
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1364,6 +1364,7 @@ void zap_page_range(struct vm_area_struc
        mmu_notifier_invalidate_range_end(&range);
        tlb_finish_mmu(&tlb, start, range.end);
 }
+EXPORT_SYMBOL_GPL(zap_page_range);

 /**
  * zap_page_range_single - remove user pages in a given range
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -3992,6 +3992,7 @@ int shmem_zero_setup(struct vm_area_stru

        return 0;
 }
+EXPORT_SYMBOL_GPL(shmem_zero_setup);

 /**
  * shmem_read_mapping_page_gfp - read into page cache, using specified page allocation flags.
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -1295,6 +1295,7 @@ int map_kernel_range_noflush(unsigned lo
 {
        return vmap_page_range_noflush(addr, addr + size, prot, pages);
 }
+EXPORT_SYMBOL_GPL(map_kernel_range_noflush);

 /**
  * unmap_kernel_range_noflush - unmap kernel VM area
@@ -1435,6 +1436,7 @@ struct vm_struct *get_vm_area(unsigned l
                                  NUMA_NO_NODE, GFP_KERNEL,
                                  __builtin_return_address(0));
 }
+EXPORT_SYMBOL_GPL(get_vm_area);

 struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,
                                const void *caller)
--- a/security/security.c
+++ b/security/security.c
@@ -751,24 +751,28 @@ int security_binder_set_context_mgr(cons
 {
        return call_int_hook(binder_set_context_mgr, 0, mgr);
 }
+EXPORT_SYMBOL_GPL(security_binder_set_context_mgr);

 int security_binder_transaction(const struct cred *from,
                                const struct cred *to)
 {
        return call_int_hook(binder_transaction, 0, from, to);
 }
+EXPORT_SYMBOL_GPL(security_binder_transaction);

 int security_binder_transfer_binder(const struct cred *from,
                                    const struct cred *to)
 {
        return call_int_hook(binder_transfer_binder, 0, from, to);
 }
+EXPORT_SYMBOL_GPL(security_binder_transfer_binder);

 int security_binder_transfer_file(const struct cred *from,
                                  const struct cred *to, struct file *file)
 {
        return call_int_hook(binder_transfer_file, 0, from, to, file);
 }
+EXPORT_SYMBOL_GPL(security_binder_transfer_file);

 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
